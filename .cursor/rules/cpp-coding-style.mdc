---
description: CPP 디렉토리 C++ 코딩 스타일 및 컨벤션
globs: CPP/**/*.cpp, CPP/**/*.hpp
alwaysApply: false
---


## 1. 코딩 스타일

### 1.1 파일명과 클래스명

- **클래스 이름과 해당 파일 이름은 동일해야 한다.**  
  - 예: `GameState` 클래스 → `GameState.hpp`
  - 추상 클래스(인터페이스)는 접두사 `I` 사용 시 `IRenderer.hpp` 등으로 파일명도 동일하게 둔다.

### 1.2 명명 규칙

- **클래스·구조체·열거형·타입 별칭**  
  - **대문자로 시작하는 카멜 표기법(PascalCase)**.  
  - 예: `GameState`, `VgaPalette`, `IRenderer`, `ResourceId`.

- **클래스 내부 멤버 변수**  
  - **`m_` 접두사** + **소문자와 언더스코어(snake_case)**.  
  - 예: `m_next_scene_id`, `m_match_settings`, `m_player_index`.

- **클래스 내부 멤버 함수**  
  - **소문자와 언더스코어(snake_case)**.  
  - 예: `get_next_scene()`, `load_har()`, `set_player_index()`.

- **멤버 함수의 매개변수(인자)**  
  - **`a_` 접두사** + **소문자와 언더스코어(snake_case)**.  
  - 예: `void set_id(int a_scene_id);`, `void load(const std::string& a_path);`.

- **지역 변수**  
  - **소문자와 언더스코어(snake_case)**. 직관적으로 이해하기 쉬운 이름 사용.  
  - 예: `scene_id`, `player_index`.

- **상수, 열거자, 매크로**  
  - **UPPER_SNAKE_CASE** (매크로),UPPER_SNAKE_CASE (constexpr·열거자).  
  - 예: `MAX_PLAYERS`

- **네임스페이스**  
  - **snake_case**. 예: `openomf::video`, `openomf::domain`.

- **작명**  
  - **직관적이고 이해하기 쉽게** 짓는다. 역할·의도가 드러나도록 한다.

### 1.3 포맷팅

- **들여쓰기**: 스페이스 **4칸**.
- **한 줄 길이**: **120자** 이내 권장 (넘을 경우 줄바꿈, 정렬 스타일 팀 합의).
- **중괄호**: K&R 스타일. 함수/클래스/제어문 `{` 다음 줄 또는 같은 줄 팀 합의 후 통일.
- **줄 끝**: LF (Unix style).

### 1.4 SOLID 원칙

다음 **SOLID** 원칙을 준수한다.

| 원칙 | 설명 | 적용 |
|------|------|------|
| **S (Single Responsibility)** | 단일 책임: 한 클래스는 하나의 변경 이유만 가져야 한다. | 클래스는 한 가지 역할만 담당. 여러 책임이 보이면 분리. |
| **O (Open/Closed)** | 개방-폐쇄: 확장에는 열려 있고 수정에는 닫혀 있어야 한다. | 새 로봇·씬·백엔드 추가 시 **기존 코드 수정 없이** 추상 클래스 구현체 추가로 확장. |
| **L (Liskov Substitution)** | 리스코프 치환: 파생 타입은 기반 타입을 대체해도 동작이 깨지지 않아야 한다. | 상속/구현 시 계약(선행·후행 조건, 불변식)을 유지. 기반 클래스 포인터로 교체해도 논리가 유지되도록. |
| **I (Interface Segregation)** | 인터페이스 분리: 클라이언트가 쓰지 않는 메서드에 의존하지 않도록 인터페이스를 작게 나눈다. | 굵은 인터페이스 대신 **역할별로 쪼갠 인터페이스**(예: IRenderable, ILoadable 분리). |
| **D (Dependency Inversion)** | 의존성 역전: 구체가 아닌 추상에 의존해야 한다. | 상위 모듈은 `IRenderer`, `IContentBackend` 등 **추상(인터페이스)** 에만 의존. 구현체는 주입·팩토리로 연결. |

- **추상 클래스**를 적절히 사용하여 확장 가능하게 설계한다.  
  예: 확장이 예상되는 **로봇(캐릭터)** 객체, **배경/씬** 객체, **콘텐츠 백엔드**, **렌더러** 등은 추상 클래스(인터페이스)로 정의하고, 구체 타입은 그 구현체로 관리한다.

### 1.5 C++ 관례 및 표준 라이브러리

- **const**: 변경 불가 인자·멤버·반환은 `const` 사용. getter는 `const` 메서드.
- **스마트 포인터**: 소유권이 있을 경우 `std::unique_ptr` / `std::shared_ptr` 사용.裸 포인터는 “참조만” 할 때.
- **RAII**: 리소스(파일, 핸들, GL 객체 등)는 생성자에서 획득, 소멸자에서 해제.
- **override / final**: 가상 함수 재정의 시 `override`, 더 이상 파생 금지 시 `final` 명시.
- **헤더**: 필요한 최소 include. 전방 선언으로 해결 가능하면 include 대체.
- **네임스페이스**: 프로젝트 루트 네임스페이스 예: `openomf`. 레이어/모듈별 하위 네임스페이스 사용 권장.
- **표준 라이브러리·STL**: **std 라이브러리를 최대한 활용**한다. `std::map`, `std::vector`, `std::string`, `std::optional`, `std::variant`, `std::unique_ptr` 등 STL을 **적극 활용**한다. 자체 구현 전에 std로 해결 가능한지 검토한다.

### 1.6 객체지향 C++ 및 이식 시 원칙

- **기존 C 코드를 C++로 옮길 때 단순 함수형으로 옮기지 않는다.**  
  **응집력이 높은 클래스**로 묶어서 설계한다. 관련 데이터와 동작을 한 클래스에 두고, 책임이 나뉘면 클래스로 분리한다.
- **`extern "C"`를 이용해 이름만 C++이고 실제로는 C인 래퍼 형식으로 구현해서는 안 된다.**  
  **진짜 객체지향 C++**로 구현한다. 상태와 동작을 클래스로 캡슐화하고, 상속·조합·추상 인터페이스를 사용한다.
- **확장 예상 대상(로봇, 배경/씬, 백엔드 등)은 추상 클래스로 추상화하여 관리한다.**  
  구체 타입은 해당 추상의 구현체로 추가하고, 상위 코드는 추상에만 의존하도록 한다(§4.4 SOLID).

### 1.7 금지·자제

- **매크로**: 상수/인라인 대체 가능하면 매크로 자제. 매크로 사용 시 UPPER_SNAKE_CASE.
- **전역 가변 상태**: 가능한 한 클래스/DI로 캡슐화.
- **using namespace std**: 헤더에서는 사용 금지. 구현 파일에서도 좁은 스코프 권장.

---

## 2. 파일 스타일

### 2.1 확장자 및 헤더 규칙

- **hpp**: 반드시 **`.hpp`** 확장자 사용. `.h` + `.cpp` 조합이 아니라 **.hpp 형태**만 사용한다.
  - C 호환 헤더가 꼭 필요한 경우만 예외적으로 `.h` 및 `extern "C"` 검토.
- **.hpp 파일**:  
  - **가독성(리더빌리티)이 좋아야 한다.**  
  - **최대 300라인을 넘지 않는다.** 넘어가면 클래스 분리·모듈 분할·전방 선언으로 줄인다.

### 2.2 파일 명명 및 클래스명 일치

- **클래스 이름과 파일 이름은 동일해야 한다**
  - **한 파일에 한 클래스**를 두는 것을 기본으로 한다.  
  - 파일명 = 클래스명 (대문자로 시작하는 카멜 표기법).  
  - 예: `GameState` 클래스 → `GameState.hpp`, `IRenderer` → `IRenderer.hpp`.
- **인터페이스(추상 클래스)**  
  - 접두사 `I` (예: `IRenderer.hpp`, `IAudioBackend.hpp`).
- **작은 타입/유틸**  
  - 여러 개를 한 헤더에 모을 수 있음. 이때도 **300라인 이내**를 유지하고, 파일명은 모듈/역할에 맞게 (예: `Types.hpp`, `Enums.hpp`).


### 2.3 헤더 가드

- **Include guard** 사용: `#ifndef OPENOMF_모듈_파일명_HPP` / `#define` / `#endif`  
  - 또는 **#pragma once** (사용 시 프로젝트 전역 통일).
- 매크로 이름: **UPPER_SNAKE_CASE**, 프로젝트 접두사 포함 (예: `OPENOMF_ENGINE_HPP`).


